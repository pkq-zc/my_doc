# DelayQueue

## 预先了解

### PriorityQueue

一个优先级无界队列.优先级按照自然顺序排序,或者用户指定的```comparator```排序.队列的头部是按指定排序最小的元素.底层有一个默认大小为11的数组保存元素,当元素个数.当随着元素的添加,内部容器会自动扩容.

### Delayed接口

继承```Comparable```接口,用来标记那些应该在给定延迟时间之后执行的对象.本身只有一个方法```getDelay(TimeUnit unit)```,用来返回延迟的剩余时间.

## 解析

```DelayQueue```内部使用全局一个独占锁```lock```保证并发安全,优先级队列```q```存储元素,```leader```用于优化内部阻塞通知的线程,```available```用户实现阻塞的Condition对象.

offer方法:

``` java
// put/add 都是调用的同一方法
public boolean offer(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            //往优先级队列添加元素
            q.offer(e);
            if (q.peek() == e) {
                leader = null;
                //唤醒等待的消费者线程
                available.signal();
            }
            return true;
        } finally {
            lock.unlock();
        }
    }
```

poll()方法

``` java
    public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            //获取头元素
            E first = q.peek();
            //如果为空或则还未到期返回null
            if (first == null || first.getDelay(NANOSECONDS) > 0)
                return null;
            else
                return q.poll(); //直接出列
        } finally {
            lock.unlock();
        }
    }
```

take 方法

``` java
    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            for (;;) {
                //获取头部元素
                E first = q.peek();
                if (first == null)
                    //队列为空,当前线程await
                    available.await();
                else {
                    //头部元素不为空,获取过期时间
                    long delay = first.getDelay(NANOSECONDS);
                    //已到过期时间
                    if (delay <= 0)
                        //直接出列
                        return q.poll();
                    //还未过期,继续执行
                    //设置first引用为空,防止后语循环等待一直持有该对象,导致该对象无法被及时回收
                    first = null;
                    if (leader != null)
                        //如果已有线程等待,则阻塞当前线程
                        available.await();
                    else {
                        //设置leader为当前线程
                        Thread thisThread = Thread.currentThread();
                        leader = thisThread;
                        try {
                            //阻塞等待指定时间
                            available.awaitNanos(delay);
                        } finally {
                            //释放leader
                            if (leader == thisThread)
                                leader = null;
                        }
                    }
                }
            }
        } finally {
            if (leader == null && q.peek() != null)
                //leader为null并且队列不为空,说明没有其他线程在等待,那就通知条件队列
                available.signal();
            lock.unlock();
        }
    }
```