# ArrayBlockingQueue和LinkedBlockingQueue

## 底层实现

### ArrayBlockingQueue

- 底层由数组实现,在创建时需要指定底层数组大小,且创建完成之后大小无法修改,所占空间的创建完成之后固定.所以在设置初始大小时,需要设置一个合适的大小,太大浪费空间,太小则缓存区太小.
- 在内部主要通过一个```items```数组存储元素,```takeIndex```记录获取元素时的索引,```pullIndex```记录添加元素时的索引.使用一个```lock```作为锁控制并发.因为用的一个锁对象,在生产者添加元素和消费者移除元素时无法做到真正的并行.同时也因为用的同一个锁对象,在初始化时,可以设置```fair```参数,使等待的生产者和消费者线程可以做到公平对待,但也会降低它的效率.
- 在每次put元素时,```putIndex```会增加1(默认从0开始),当put到最后一个位置时,会把```pullIndex```设置成0.在每次take元素时,```takeIndex```也会增加1(默认从0开始),当take到最后位置时,会把```takeIndex```设置为0.正是上面的逻辑,保证了队列FIFO(先进先出)的特性.

构造函数:

``` java
public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity <= 0)
            throw new IllegalArgumentException();
        this.items = new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    }
```

put时关键代码:

``` java
public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }

private void enqueue(E x) {
        final Object[] items = this.items;
        items[putIndex] = x;
        //putIndex加1,如果已到达数组最后索引,重置为0
        if (++putIndex == items.length)
            putIndex = 0;
        count++;
        notEmpty.signal();
    }
```

take关键代码:

``` java
public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0)
                notEmpty.await();
            return dequeue();
        } finally {
            lock.unlock();
        }
    }

private E dequeue() {
        final Object[] items = this.items;
        @SuppressWarnings("unchecked")
        E x = (E) items[takeIndex];
        items[takeIndex] = null;
        //takeIndex加1,如果已到达数组最后索引,重置为0
        if (++takeIndex == items.length)
            takeIndex = 0;
        count--;
        if (itrs != null)
            itrs.elementDequeued();
        notFull.signal();
        return x;
    }
```

### LinkedBlockingQueue

- 底层由单向链表组成.使用单项链表不需要提前分配内存空间.默认长度为```Integer.MAX_VALUE```,推荐自定义合适长度.如果没有设置合适长度,容易造成OOM.

- 内部使用```capacity```保存最大长度,使用一个```AtomicInteger count```保存当前链表长度,使用```head```和```last```分别保存链表的首节点和尾节点.与```ArrayBlockingQueue```很大区别的另一个地方是,它的内部使用了```takeLock```和```putLock```两个锁,在头节点和尾节点的两个锁不会相互竞争,所以相对于```ArrayBlockingQueue```它是可以做到真正的并行读写的.但也因为使用了两把锁,导致等待在队列上的生产者和消费者线程无法实行公平策略.

构造函数:

``` java
public LinkedBlockingQueue(int capacity) {
        if (capacity <= 0) throw new IllegalArgumentException();
        //设置容量
        this.capacity = capacity;
        //设置链表表头和表尾
        last = head = new Node<E>(null);
    }
```

put核心代码:

``` java
    public void put(E e) throws InterruptedException {
        if (e == null) throw new NullPointerException();
        int c = -1;
        Node<E> node = new Node<E>(e);
        final ReentrantLock putLock = this.putLock;
        final AtomicInteger count = this.count;
        putLock.lockInterruptibly();
        try {
            while (count.get() == capacity) {
                notFull.await();
            }
            //链表添加节点
            enqueue(node);
            //元素个数+1
            c = count.getAndIncrement();
            if (c + 1 < capacity)
                notFull.signal();
        } finally {
            putLock.unlock();
        }
        if (c == 0)
            //如果之前队列为空,消费者全在wait(),需要调用该方法唤醒消费者消费
            signalNotEmpty();
    }

    private void enqueue(Node<E> node) {
        last = last.next = node;
        //等同于下面代码:
        //last.next = node;
        //last = last.next
        //向将老last的next指向新添加的节点,然后再把last节点设置成新节点
    }
```

take核心代码:

```java
public E take() throws InterruptedException {
        E x;
        int c = -1;
        final AtomicInteger count = this.count;
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();
        try {
            while (count.get() == 0) {
                notEmpty.await();
            }
            //获取头节点的值
            x = dequeue();
            //元素个数-1
            c = count.getAndDecrement();
            if (c > 1)
                notEmpty.signal();
        } finally {
            takeLock.unlock();
        }
        if (c == capacity)
            //如果之前队列满了,所有生产者都在wait(),需要唤醒生产者线程生产
            signalNotFull();
        return x;
    }

private E dequeue() {
        //使用h保存头当前的头节点
        Node<E> h = head;
        //使用first保存当前头结点的下个节点(出列完成之后变成新的头节点)
        Node<E> first = h.next;
        //设置当前头结点为自己,方便垃圾回收
        h.next = h;
        //设置新的头节点
        head = first;
        //获取取出来的值
        E x = first.item;
        //设置新的头节点item为空
        first.item = null;
        //返回取到的值
        return x;
    }
```
