# java多线程之wait和notify

## wait

该方法用来将线程置于WAITING(没有超时时间)或者TIMED_WAITING(有超时时间)状态,直到接到通知(notify),中断(interrupt)或者超时(timeOut).在调用wait()方法之前,线程必须已经获得该对象的对象级别锁,通常只能在同步代码块或者同步方法中调用,如果不是,将会报```IllegalMonitorStateException```异常.当该方法调用之后,当前线程就会释放所持的对象锁.

## notify和notifyAll

该方法用户通知那些可能等待在该对象上的对象锁的线程.如果是多个线程,调用该方法将随机唤醒一个(notify)或者多个(notifyAll)等待的线程.该方法同wait类似,也需要在同步代码块或者同步方法中调用,如果不是,同样将报```IllegalMonitorStateException```异常.当该方法被调用后,不会立马放掉对象锁,需要等待代码执行完,退出同步代码块或者同步方法才会释放锁.

## 锁池和等待池

在java对象中,每个对象都有一个与之唯一对应的内部锁(Monitor).java虚拟机会为每一个对象维护两个队列(暂且称之为队列),一个就是锁池,另外一个就是等待池.

- 锁池:存储等待获取objectX对应的内部锁的所有线程
- 等待池:于存储执行了objectX.wait()/wait(long)的线程

``` java
public class Ch2 {
    public static void main(String[] args) throws InterruptedException {
        Object o = new Object();
        Runnable runnable = () -> {
            synchronized (o){
                try {
                    o.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                while (true){

                }
            }
        };

        Thread t1 = new Thread(runnable, "t1");
        Thread t2 = new Thread(runnable, "t2");
        Thread t3 = new Thread(runnable, "t3");
        t1.start();
        t2.start();
        t3.start();
        //确保t1.t2.t3正常启动
        Thread.sleep(1000L);

        System.out.println("t1.getState() = " + t1.getState());
        System.out.println("t2.getState() = " + t2.getState());
        System.out.println("t3.getState() = " + t3.getState());

        //调用notifyAll唤醒所有
        Thread t4 = new Thread(() -> {
            synchronized (o) {
                o.notifyAll();
                System.out.println("============调用了notifyAll,代码块还未执行完===============");
                System.out.println("t1.getState() = " + t1.getState());
                System.out.println("t2.getState() = " + t2.getState());
                System.out.println("t3.getState() = " + t3.getState());

            }
        });
        t4.start();
        //确保 调用notifyAll的线程执行完
        Thread.sleep(1000L);
        System.out.println("============调用了notifyAll,代码块已经执行完===============");
        System.out.println("t1.getState() = " + t1.getState());
        System.out.println("t2.getState() = " + t2.getState());
        System.out.println("t3.getState() = " + t3.getState());
    }
}
```

打印结果如下:

``` shell
t1.getState() = WAITING
t2.getState() = WAITING
t3.getState() = WAITING
============调用了notifyAll,代码块还未执行完===============
t1.getState() = BLOCKED
t2.getState() = BLOCKED
t3.getState() = BLOCKED
============调用了notifyAll,代码块已经执行完===============
t1.getState() = BLOCKED
t2.getState() = BLOCKED
t3.getState() = RUNNABLE
```

1. 线程t1,t2,t3先启动,因为调用了wait()方法,释放了对象锁,进入等待池中等待唤醒,此时三个线程的状态都是```WAITING```状态
2. t4线程调用notifyAll()唤醒了t1,t2,t3线程,在还未执行完所有的同步代码快中打印三个线程的状态都为```BLOCKED```,三个线程都已经进入了锁池,等待该线程把对象锁释放.
3. t4线程执行完毕,退出同步代码块,释放对象锁.线程t1,t2,t3同时抢对象锁,但是谁抢到这个是随机的.结果是t3抢到锁,进入无限while循环,t1,t2因为没有抢到锁,留在锁池等待对象锁.三个线程的状态分别为```BLOCKED```,```BLOCKED```,```RUNNABLE```与上述过程吻合.

## 当前线程调用wait()只会释放当前共享变量上面的锁

当前线程调用共享对象上的wait时,只会释放当前共享变量上面的锁.如果该线程还带有其他共享对象的锁,是不会释放的.如果这点没有注意,很容易发生死锁.

``` java
public class Ch3 {
    public static void main(String[] args) {
        Object resourceA = new Object();
        Object resourceB = new Object();

        Runnable runnable = () -> {
            synchronized (resourceA){
                System.out.println(Thread.currentThread().getName()+":获取resourceA的锁");
                synchronized (resourceB){
                    System.out.println(Thread.currentThread().getName()+":获取resourceB的锁");
                    try {
                        resourceA.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+":wait唤醒之后执行内容");
                }
            }
        };

        Thread t1 = new Thread(runnable, "t1");
        Thread t2 = new Thread(runnable, "t2");
        t1.start();
        t2.start();
    }
}
```

上面的代码执行结果如下:

```
t1:获取resourceA的锁
t1:获取resourceB的锁
t2:获取resourceA的锁
```

代码最后卡死在t2获取```resourceB```上.因为```t1```在执行只释放了```resourceA```对象上的锁,而```resourceB```上面的锁并未被释放,最后导致另一个线程在等待锁的释放产生了死锁.

## 使用案例-生产者和消费者

### 一个生产者和一个消费者

示例代码如下:

```java
public class Ch1 {
    public static void main(String[] args) {
        Person p = new Person(1,0);
        Thread p1 = new Thread(new Producers(p), "生产者线程-1");
        Thread c1 = new Thread(new Consumer(p), "消费者线程-1");
        p1.start();
        c1.start();
        while (true){

        }
    }
}

class Person {
    private final Integer maxStore;
    private Integer currentStore;

    public Person(Integer maxStore, Integer currentStore) {
        this.maxStore = maxStore;
        this.currentStore = currentStore;
    }

    /**
     * 增加库存
     */
    public synchronized void add() {
        if (currentStore >= maxStore){
            try {
                System.out.println(Thread.currentThread().getName() + "数量已满,等待消费");
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        currentStore++;
        System.out.println(Thread.currentThread().getName() + ":生产之后的数量为[" + currentStore + "]");
        this.notify();
    }

    /**
     * 减少库存
     */
    public synchronized void remove() {

        if (currentStore <= 0){
            try {
                System.out.println(Thread.currentThread().getName() + "数量不足,等待生产");
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        currentStore--;
        System.out.println(Thread.currentThread().getName() + ":消费之后的数量为[" + currentStore + "]");
        this.notify();
    }
}

/**
 * 生产者
 */
class Producers implements Runnable{
    private final Person p;

    public Producers(Person p) {
        this.p = p;
    }

    @Override
    public void run() {
        while (true){
            p.add();
        }
    }
}

/**
 * 消费者
 */
class Consumer implements Runnable{
    private final Person p;

    public Consumer(Person p) {
        this.p = p;
    }

    @Override
    public void run() {
        while (true){
            p.remove();
        }
    }
}
```

上面的代码就是一个简单的生产者和消费者模型.p1(生产者)每次执行把数量加1,c1(消费者)每次执行把数量减1.在一个生产者和一个消费者的情况下,代码可以正常执行,没有问题.

### 一个生产者和多个消费者引发的过度消费问题

修改代码如下:

``` java
        Person p = new Person(1,0);
        Thread p1 = new Thread(new Producers(p), "生产者线程-1");
        Thread c1 = new Thread(new Consumer(p), "消费者线程-1");
        Thread c2 = new Thread(new Consumer(p), "消费者线程-2");
        p1.start();
        c1.start();
        c2.start();
```

与之前代码不同的时,添加一个消费者线程,再次执行.从打印的结果可以看出,有些时候打印的数量会小于0.这是什么原因导致的呢?

1. 如果```currentStore = 0```,c1和c2因为```currentStore <= 0```所以等待,执行wait()等待.
2. 因为```currentStore = 0```,p1执行```currentStore++```后,调用notify唤醒c1,此时```currentStore = 1```.
3. c1被唤醒,执行```currentStore--```后,唤醒c2,此时```currentStore = 0```.
4. c2被唤醒,执行```currentStore--```,此时```currentStore = -1```.

从上面分析步骤可以看出,在执行第3步时,有问题.因为notify唤醒的可能是生产者,也可能是消费者.如果唤醒的是生产者时,并无问题,但现在唤醒的是消费者,所以才出现数量小于0的情况.主要原因是,当消费者这被唤醒后,作为wait()的条件已经发生了改变,才导致了这种情况的发生.所以我们只需要修改代码,将原先的```if```修改为```while```即可.这也是javaDoc推荐的方式.

### 一个生产者和多个消费者引发的死循环

根据上个示例的建议,wait()条件判断中的```if```改成为```while```.

```java
//将if 改成while
while (currentStore >= maxStore){
            try {
                System.out.println(Thread.currentThread().getName() + "数量已满,等待消费");
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
//将if 改成while
while (currentStore <= 0){
            try {
                System.out.println(Thread.currentThread().getName() + "数量不足,等待生产");
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
```

运行代码一会儿之后,发现控制台不再打印.使用```jvisualvm```查看,线程的状态如下:
![线程状态图](https://i.loli.net/2019/10/30/bVSKp5LkOX7NaIj.png)

查看发现,生产者线程和消费者线程全部处于```WAITING```状态状态.那么为什么会处于该状态呢?

1. 如果```currentStore = 0```,c1和c2因为```currentStore <= 0```所以等待,执行wait()等待.
2. 因为```currentStore = 0```,p1执行```currentStore++```后,调用notify唤醒c1,此时```currentStore = 1```.
3. c1被唤醒,执行```currentStore--```后,唤醒c2,此时```currentStore = 0```.
4. c2被唤醒,此时```currentStore <= 0```满足,c2调用wait()方法,释放锁.p1,c1,c2全部进入等待池,全部等待唤醒.

从上面的分析案例可以知道,因为每次调用notify(),不能控制唤醒哪个线程,最坏的结果可能导致所有的线程都在等待池中等待唤醒,所有的线程进入了```WAITING```状态,所有控制台不再有任何输出.解决这个问题的方案为,将```notify()```替换为```notifyAll()```.这样就能解决所有的线程进入等待池这个问题.

[示例代码](https://github.com/pkq-zc/current/tree/master/src/main/java/com/buydeem/wait_notify "示例代码")
