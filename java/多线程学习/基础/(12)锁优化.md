# (12)锁优化

## 简叙

在JDK1.5之前提供的原生锁```synchronized```的性能并不是很好,直到JDK1.6对锁进行了大量优化.主要优化有下面几点:

- 适应性自旋
- 锁消除
- 锁粗化
- 轻量级锁
- 偏向锁

## 自旋锁与自适应锁

### 自旋锁

通过同步互斥对性能最大的影响就是在于阻塞.当线程无法获取到对象锁时执行挂起,当锁释放时需要将等待锁的线程恢复,这个过程是非常低效的.但是实际开发中我们```对共享数据的锁定状态只会持续很短的时间```,为了这一小段时间去挂起线程然后再恢复这是不值得的.在有一个以上的处理器的机器上,能让两个或者两个以上的线程同时并发执行,我们可以让后面那个线程"稍等一下",但不放弃处理器的执行时间,看看持有锁的线程是否会很快释放锁.为了让线程等待,我们只需要让线程执行一个忙循环(自旋),这项技术就是所谓的```自旋锁```.  
自旋锁在JDK1.6以上默认为打开,在1.4和1.5中需要通过```使用- XX:+ UseSpinning```开启.需要明白的是自旋和阻塞是不能互相替换的.自旋并没有放弃所持有的处理器时间片,进入自旋只是为了避免线程切换的开销.如果共享资源锁定时间短,使用自旋能避免线程切换提高并发性.如果共享资源锁定时间太长,如果还继续自旋等待只会白白浪费CPU资源.因此自旋的次数必须要有一定的限度,如果自旋超过一定次数还是没有获取锁成功,就应该使用传统的方式去挂起线程.默认自旋次数为10次,可以通过```-XX: PreBlockSpin```进行更改.

### 适应性自旋锁

在1.6中引入了自适应性自旋锁.自适应是指```自旋的时间不再是固定的了,而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的```.如果在同一个锁对象上,自旋等待刚刚成功获得过锁,并且持有锁的线程正在运行中,那么虚拟机就会任务这次自旋也很可能成功,进而允许自旋等待持续相对更长的时间,比如100个循环.如果对于某个锁自旋很少成功获得过,那在以后要获取这个锁时将可能省略掉自旋过程,避免浪费处理器资源.

## 锁消除

锁消除是指```虚拟机即时编译器在运行时,对于一些代码上要求同步,但是检测到不可能存在共享数据竞争的锁进行消除```.这个判断依据主要来源于逃逸分析的数据支持,如果在一段代码中,堆上所有数据都不会逃逸出去从而被其他线程访问到,那就可以把它当做栈上的数据对待,认为他们是线程私有的直接去掉同步加锁.  

```java
    public String method1(){
        Object o = new Object();
        synchronized (o){
            return "hello world";
        }
    }
```

上面这个```method1```方法中有同步代码块,这个在即时编译时会被消除.因为```o```是方法内部的一个变量,是不会被其他线程所竞争的.

## 锁粗化

在我们编写代码是,原则上同步代码块的作用范围限制的越小越好.这样做使得等待锁的线程等待时间变短.大部分情况下这个原则是正确的.但是如果一系列连续操作都是对同一个对象反复的加锁和结果,甚至加锁操作出现在循环体中.即使没有线程竞争,频繁的进行互斥同步操作也会导致不必要的性能损耗.

```java
public void method2(){
        for (int i = 0; i < 20; i++) {
            synchronized (o){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
```

例如这个方法,因为在```for```中线程需要频繁的加锁和释放锁.在即时编译中,它会将锁粗化提出在循环之外.这样可以避免频繁加锁和释放锁,提高并发能力.

## 轻量级锁

轻量级锁是在JDK1.6中引入的.它的轻量级是相对于使用系统互斥量而言的传统锁而言的,因此传统的锁机制就称作"重量级"锁.  

### Mark Word

如果要了解轻量级锁和后面的偏向锁的原理,首先得先了解HotSpot虚拟机对象的对象头的内存说起.对象头主要分为两个部分,第一部分用于存储对象自身的运行时数据,如果哈希码(HashCode).GC分代年龄等,这部分的长度在32位和64位虚拟机中分别为32bit和64bit,官方称它为"Mark Word",它是实现轻量级锁和偏向锁的关键.对象头还有其他部分跟锁没多大关系我们暂时不了解它了.  
因为这个对象头跟对象自定义的数据无关但是却会占用额外的存储成本,所以"Mark Word"被设计成一个无固定数据结构以便于用很小的控件存储更多的信息,这也造成了对象不同状态下存储的内容不相同这样一个局面.下面举例说一下32位虚拟机中,一个普通对象的"Mark Word"的结构.  

![32位虚拟机Mark Word结构](https://i.loli.net/2020/07/08/ITiJfn8GRtqCuSW.png)  

### 栈帧

这个内容比较多也比较复杂,你只要明确知道一点就是每个线程都有自己独立的内存空间,栈帧就是独立空间中的一部分.有点类似于```ThreadLocal```一样的东西.

### 过程分析

1. 在代码进入同步块的时候,如果此同步对象没有被锁定(锁标志位为"01"状态,是否为偏向锁为"0",如果是否为偏向锁为"1"就是偏向锁了,后面会讲),虚拟机会把锁对象的```Mark Word```内容拷贝到栈帧中.
2. 然后虚拟机将使用CAS操作尝试将锁对象的```Mark Word```内容更新为指向栈中锁记录的指针.如果这个动作成功,那么就表示当前线程拥有了该对象的锁.并且还会将对象的锁标志位修改为"00",表示此对象处于轻量级锁定状态.
3. 如果操作2失败.虚拟机会检查对象的```Mark Word```是否指定当前线程的栈帧,如果```是```说明当前线程已经拥有了这个对象的锁,直接进入同步代码块继续执行即可.否则说明这个锁对象被其他线程抢占了.这个时候轻量级锁就不再有效了,因为存在两个以上的线程抢同一个锁,锁膨胀为重量级锁.锁标志的状态值变为"10",```Mark Word```中存储的就是指定重量级锁(互斥量)的指针,后面等待锁的线程也要进入阻塞状态.

上面是加锁状态.它的解锁状态也是通过CAS操作来实现的.如果对象的```Mark Word```任然指向线程的锁记录,那就用CAS操作把对象当前的```Mark Word```和线程栈帧中复制的信息替换回来.如果替换成功,整个同步过程就完成了.如果替换失败,说明中途有其他线程尝试过获取该锁,那在释放锁的同时还需要唤醒挂起的线程.  

轻量级锁能提升程序同步性主要是 依靠```绝大部分的锁,在整个同步周期内不存在竞争```这个条件.如果没有竞争,只需要轻量级锁使用```CAS```操作避免使用互斥量的开销.但是如果存在锁竞争的话,除了互斥量的开销,还要加上额外的CAS操作.因此在有激烈竞争的情况下,使用轻量级锁并不能带来性能上的提升,反而还会降低性能.

## 偏向锁

偏向锁也是JDK1.6中的引入的一项锁优化,它的目的是消除数据在无竞争状态下的同步原语,进一步提高程序的运行性能.我们可以通过```XX:+ UseBiasedLocking```来控制是否打开偏向锁,默认情况下为打开.```轻量级锁在无竞争的情况下使用CAS操作去消除同步时使用的互斥量,而偏向锁就是在无竞争的情况下把整个同步都消除掉了,连CAS操作都不进行```.
