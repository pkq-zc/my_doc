# AQS

## 简叙

之前我写过很多关于JUC下各种锁的使用文章,但是都没说是如何实现的.如果你去看```ReentrantLock```的源码,你会发现它内部有一个```Sync```类,它继承了```AbstractQueuedSynchronizer```这个抽象类实现了该类的某些方法.这个就是我们今天要说的```AQS```.我们一定先要搞懂这个类才能真正的了解到```ReentrantLock```它是如何实现的.  

## 阅读预备知识点

- ```CAS```:需要知道什么是CAS.简单的说就是```比较```和```交换```.举个简单的例子:例如你去更新数据中的订单状态为```未支付```的订单为```已支付```.你的sql语句必须是```update t_order set status = '已支付' where status = '未支付'```.而不应该是```update t_order set status = '已支付'```.如果还是不理解可以查看我们之前写的关于[CAS](https://www.jianshu.com/p/171652d2a971)的文章.

- ```volatile```:需要知道```volatile```关键字的作用.简单的说使用它修饰的变量,只要值发生改变在其他线程能立马看见改变后的值.可以参考我之前写的关于[volatile](https://www.jianshu.com/p/a11e2c6a89aa)相关的文章.

- ```链表和队列```:因为AQS其中的一个重要部分就是队列,这个队列是通过一个双向链表实现的.如果你懂链表和队列的实现,那么你在理解起来将会比较容易.

## 核心思想

对于共享资源主要就是由两种状态:

- ```空闲```:如果当前请求的共享资源空闲,那么就将当前请求资源的线程设置为有效线程.
- ```占用```:如果当前请求的共享资源被占用,那么就需要一种机制让当前的请求排队等待.

而AQS就是对上述描述的实现.在AQS的内部使用了一个```volatile```修饰的变量```state```来代表共享资源,使用一个FIFO队列来存储等待的线程.同时AQS内部共享资源的方式也有两种:```Exclusive(独占,例如ReentrantLock等)```和```Share(共享,例如CountDownLatch等)```.