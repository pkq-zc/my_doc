# mysql索引的最左匹配原则

## 试验环境

mysql版本为```5.7```,存储引擎为```InnoDB```.

## 示例

```sql
EXPLAIN SELECT * FROM `t_user` WHERE first_name = '陈' AND last_name = '梅';
EXPLAIN SELECT * FROM `t_user` WHERE last_name = '陈' AND first_name = '梅';
EXPLAIN SELECT * FROM `t_user` WHERE last_name = '陈' OR first_name = '梅';
EXPLAIN SELECT * FROM `t_user` WHERE last_name = '陈';
```

结果如下:

```
+----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref         | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | t_user | NULL       | ref  | index_1       | index_1 | 2046    | const,const |   66 |      100 | NULL  |
+----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+

+----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref         | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | t_user | NULL       | ref  | index_1       | index_1 | 2046    | const,const |    1 |      100 | NULL  |
+----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+

+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | t_user | NULL       | ALL  | index_1       | NULL | NULL    | NULL | 1995967 |       19 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+

+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | t_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1995967 |       10 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+---------+----------+-------------+
```

结果显示,一二条是符合最左匹配原则的,后面两条则不匹配.在Mysql的官方文档中指出,```如果表拥有一个联合索引,任何一个索引的最左前缀都会被优化器用于查找列.比如,如果你创建了一个三列的联合索引包含(col1, col2, col3),你的索引会生效于(col1),(col1, col2), 以及(col1, col2, col3).  
官方文档出处:[Multiple-Column Indexes](https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html)

## 原理

最左匹配原则是针对联合索引来说的,这点首先要明确.假设创建一个联合索引(a,b),那么它们的结果将如下如所示![B+树索引.png](https://img2018.cnblogs.com/blog/1281680/201901/1281680-20190117145740508-758737271.png)  
从图中我们可以看出a的顺序值为(1,1,2,2,3,3),它是按照从小到大的顺序规则排列的,但是b的值并不遵循这个规律.当a的值相同时,可以看见b也是遵循该规律的.这就是为什么mysql多列联合索引需要遵循最左原则的原因了.
